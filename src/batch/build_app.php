<?php
/**
 * Parse Vite manifest file and output a config file for SymfonyÂ´s web
 * response to output javascript/stylesheet include tags for Vite dev
 * server and production build.
 *
 *   NOTE : UNUSED OLD CODE HANDLING VERSIONING OF STANDALONE CSS/JS
 *          FILES, MIGHT BE USEFUL LATER.
 *
 * Usage:
 *
 *   php batch/build_app.php --webroot <path> --out <file.php>
 *
 * Example:
 *
 *   > vite build
 *   > php batch/build_app.php -w web --vite web/build/dist/manifest.json -o config/vite.inc.php
 *
 * @author   Fabrice Denis
 */
require_once realpath(dirname(__FILE__).'/..').'/lib/batch/Command_CLI.php';

class BuildApp extends Command_CLI
{
  // list of resources for which we want versioning
  // - use GLOB PATTERNS
  // - MUST be descendants of the --webroot option
  const INCLUDE_ASSETS = [
    // 'web/build/revtk/*.min.js',
    // 'web/build/pack/*.min.css',
    // 'web/build/pack/*.min.js',
  ];

  public function __construct()
  {
    parent::__construct([
      'webroot|w=s' => 'The web document root (required)',
      'out|o=s' => 'Output filename (required)',
      'list|l' => 'List all versioned resources and exits',
      'vite=s' => 'Include vite entries, parse manifest.json',
    ]);

    $this->webPath = $this->opts->webroot;
    if (null === $this->webPath)
    {
      $this->throwError('Required --webroot flag. Type --help for help.');
    }

    $files = $this->crawl(self::INCLUDE_ASSETS);

    if ($this->getFlag('list'))
    {
      echo implode("\n", $files);
      echo sprintf("\n\n%s versioned resources.\n", count($files));

      exit();
    }

    $this->verbose("\n%s versioned resources.\n", count($files));

    $outfile = $this->getFlag('o');
    if (null === $outfile)
    {
      $this->throwError('Required --out flag. Type --help for help.');
    }

    // $contents = $this->build($files);
    $generatorTime = date('F j, Y G:i:s');
    $generatorFile = basename(__FILE__);
    $contents = <<<EOD
<?php
/**
 * Generated by `build_app.php`This file was generated by script "{$generatorFile}"
 * 
 * @date    {$generatorTime}
 */
EOD;

    if (null !== ($manifest = $this->getFlag('vite')))
    {
      $contents = $contents
        ."\n\n"
        .$this->parseViteManifest($manifest);

      $this->verbose("Vite manifest parsed.\n");
    }

    if (false === file_put_contents($outfile, $contents))
    {
      $this->throwError('Error writing to outfile "%s".', $outfile);
    }

    $this->verbose('Success! (output file "%s").', $outfile);
  }

  /**
   * Replace any Windows-style backslashes with slashes.
   *
   * @param string $path Fully qualified path name
   *
   * @return string
   */
  protected function normalizeForwardSlashes($path)
  {
    return preg_replace('/[\/\\\]/', '/', $path);
  }

  /**
   * PHP var_export() with short array syntax (square brackets) indented 2 spaces.
   *
   * NOTE: The only issue is when a string value has `=>\n[`, it will get converted to `=> [`
   *
   * @see https://www.php.net/manual/en/function.var-export.php
   *
   * @author  https://gist.github.com/stemar/f4cc560e2bb96b99d1e3af292fb3ee20
   *
   * @param mixed $expression
   */
  private function varexport($expression, bool $return = true)
  {
    $export = var_export($expression, true);
    $patterns = [
      '/array \\(/' => '[',
      '/^([ ]*)\\)(,?)$/m' => '$1]$2',
      "/=>[ ]?\n[ ]+\\[/" => '=> [',
      "/([ ]*)(\\'[^\\']+\\') => ([\\[\\'])/" => '$1$2 => $3',
    ];
    $export = preg_replace(array_keys($patterns), array_values($patterns), $export);

    if ((bool) $return)
    {
      return $export;
    }
    else
    {
      echo $export;
    }
  }

  private function crawl(array $includeAssets)
  {
    $assets = [];

    foreach ($includeAssets as $pattern) {
      $files = glob($pattern);
      $assets = array_merge($assets, $files);
    }

    $assets = array_map(function($path) {
      return $this->normalizeForwardSlashes($path);
    }, $assets);

    return $assets;
  }

  /**
   * Parse manifest.json from vite build.
   *
   * @param string $file [description]
   *
   * @return [type] [description]
   */
  private function parseViteManifest(string $file)
  {
    if (false === ($jsonText = file_get_contents($file)))
    {
      $this->throwError('Could not read manifest file "%s".', $file);
    }

    if (null === ($manifest = json_decode($jsonText, true)))
    {
      $this->throwError('Error parsing JSON in manifest file "%s".', $file);
    }

    $entries = [];

    foreach ($manifest as $chunk => $chunkInfo)
    {
      if (!isset($chunkInfo['isEntry']))
      {
        continue;
      }

      $imports = $chunkInfo['imports'] ?? [];
      $deps = [];
      foreach ($imports as $importChunk)
      {
        $deps[] = $manifest[$importChunk]['file'] ?? '-ERROR-';
      }

      // output format
      $entries[$chunk] = [
        'file' => $manifest[$chunk]['file'],
        'deps' => $deps,
        'css' => $manifest[$chunk]['css'],
      ];
    }

    // print_r($entries);exit;

    return $this->formatEntries($entries);
    // echo $output;exit;
  }

  private function formatEntries(array $entries)
  {
    ob_start();

    echo <<<'EOD'
    // Vite build entries & dependencies.
    EOD;

    echo "\nreturn ";

    echo $this->varexport($entries);

    echo ";\n";

    return ob_get_clean();
  }

  /**
   * Create the php file that can be included to have timestamp information
   * for all the revved files.
   *
   * @param mixed $files
   *
   * @return string Content to save as a php file
   */
  private function build($files)
  {
    // start buffering content of this file
    ob_start();

    echo "\nreturn [\n";

    // noralize basepath of web document root to be substracted from the resource urls
    $basePath = $this->normalizeForwardSlashes(realpath($this->webPath));

    $assets = [];

    foreach ($files as $file)
    {
      $realFile = realpath($file);

      $timestamp = filemtime($realFile);

      // use as array key, the absolute url relative from the web root
      // (this should match the url passed to the stylesheet and javascript include helpers)
      $resourcePath = '/'.$this->getRelativePathFrom($realFile, $basePath);

      $assets[] = "'{$resourcePath}' => {$timestamp}";
    }

    echo implode(",\n", $assets)."\n];";

    return ob_get_clean();
  }
}

$cmd = new BuildApp();
